<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow-x: hidden;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: block;
            z-index: -1;
            /* Object-fit: cover via CSS is ignored by Canvas drawing, 
               so we handle the "cover" math in JS below */
            pointer-events: none;
        }

        .text-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 0;
        }

        #spacer {
            /* Default for Desktop */
            height: 100000px;
        }

        /* Adjust for Mobile (screens smaller than 768px) */
        @media (max-width: 767px) {
            #spacer {
                /* 10x less than desktop */
                height: 10000px;
            }
        }
    </style>
</head>

<body>

    <div class="text-container">scroll</div>
    <canvas id="anim-canvas"></canvas>
    <div id="spacer"></div>

    <script>
        const canvas = document.getElementById('anim-canvas');
        const ctx = canvas.getContext('2d');

        const settings = {
            totalFrames: 2001,
            perSheet: 100,
            isMobile: window.innerWidth < 768,
            sourceWidth: window.innerWidth < 768 ? 150 : 300,
            sourceHeight: window.innerWidth < 768 ? 200 : 400
        };

        // Store decoded Bitmaps here for instant drawing
        let loadedBitmaps = {};

        async function init() {
            // 1. Immediately render the first sheet
            await loadAndDrawFirstFrame();

            // 2. Listen for scroll to handle the rest
            window.addEventListener('scroll', () => {
                requestAnimationFrame(updateFrame);
            });
        }

        async function loadAndDrawFirstFrame() {
            const firstSheetUrl = getSheetUrl(0);
            const bitmap = await fetchAndDecode(firstSheetUrl);
            if (bitmap) {
                loadedBitmaps[firstSheetUrl] = bitmap;
                render(0); // Draw frame 0 immediately
            }
        }

        function getSheetUrl(index) {
            const mode = settings.isMobile ? 'mobile' : 'desktop';
            return `./output/${mode}_sheet_${index}.jpg`;
        }

        async function fetchAndDecode(url) {
            try {
                const response = await fetch(url);
                const blob = await response.blob();
                // This decodes the JPG off the main thread!
                return await createImageBitmap(blob);
            } catch (e) {
                console.error("Failed to load sheet:", url);
                return null;
            }
        }

        function updateFrame() {
            const scrollTop = window.scrollY;
            const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
            const scrollFraction = Math.max(0, Math.min(1, scrollTop / maxScroll));
            render(scrollFraction);
        }

        async function render(scrollFraction) {
            const frameIndex = Math.floor(scrollFraction * (settings.totalFrames - 1));
            const sheetIndex = Math.floor(frameIndex / settings.perSheet);
            const indexInSheet = frameIndex % settings.perSheet;
            const sheetUrl = getSheetUrl(sheetIndex);

            if (loadedBitmaps[sheetUrl]) {
                drawFrame(loadedBitmaps[sheetUrl], indexInSheet);
            } else {
                // If not loaded, fetch it and it will show up on the next scroll tick
                fetchAndDecode(sheetUrl).then(bitmap => {
                    if (bitmap) loadedBitmaps[sheetUrl] = bitmap;
                });
            }
        }

        function drawFrame(imageBitmap, index) {
            // Calculate "Cover" scale
            const scale = Math.max(canvas.width / settings.sourceWidth, canvas.height / settings.sourceHeight);
            const x = (canvas.width / 2) - (settings.sourceWidth / 2) * scale;
            const y = (canvas.height / 2) - (settings.sourceHeight / 2) * scale;

            // Drawing an ImageBitmap is significantly faster than a raw Image object
            ctx.drawImage(
                imageBitmap,
                0, index * settings.sourceHeight, settings.sourceWidth, settings.sourceHeight,
                x, y, settings.sourceWidth * scale, settings.sourceHeight * scale
            );
        }

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            updateFrame();
        });

        // Start the engine
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        init();
    </script>
</body>

</html>