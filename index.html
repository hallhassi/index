<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow-x: hidden;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: block;
            z-index: -1;
            /* Object-fit: cover via CSS is ignored by Canvas drawing, 
               so we handle the "cover" math in JS below */
            pointer-events: none;
        }

        .text-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 0;
        }

        #spacer {
            /* Default for Desktop */
            height: 100000px;
        }

        /* Adjust for Mobile (screens smaller than 768px) */
        @media (max-width: 767px) {
            #spacer {
                /* 10x less than desktop */
                height: 10000px;
            }
        }
    </style>
</head>

<body>

    <div class="text-container">scroll</div>
    <canvas id="anim-canvas"></canvas>
    <div id="spacer"></div>

    <script>
        const canvas = document.getElementById('anim-canvas');
        const ctx = canvas.getContext('2d');

        const settings = {
            totalFrames: 2001,
            perSheet: 100,
            isMobile: window.innerWidth < 768,
            sourceWidth: window.innerWidth < 768 ? 150 : 300,
            sourceHeight: window.innerWidth < 768 ? 200 : 400
        };

        let loadedBitmaps = {};
        let loadingTracker = {}; // NEW: Keeps track of active fetches

        async function init() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // 1. Immediately render the first sheet
            await loadAndDrawFirstFrame();

            // 2. Listen for scroll
            window.addEventListener('scroll', updateFrame, { passive: true });
        }

        async function loadAndDrawFirstFrame() {
            const firstSheetUrl = getSheetUrl(0);
            loadingTracker[firstSheetUrl] = true; // Mark as loading
            const bitmap = await fetchAndDecode(firstSheetUrl);
            if (bitmap) {
                loadedBitmaps[firstSheetUrl] = bitmap;
                render();
            }
        }

        function getSheetUrl(index) {
            const mode = settings.isMobile ? 'mobile' : 'desktop';
            return `./output/${mode}_sheet_${index}.jpg`;
        }

        async function fetchAndDecode(url) {
            try {
                const response = await fetch(url);
                const blob = await response.blob();
                return await createImageBitmap(blob);
            } catch (e) {
                console.error("Failed to load sheet:", url);
                delete loadingTracker[url]; // Allow retry if it failed
                return null;
            }
        }

        function updateFrame() {
            // RequestAnimationFrame is better for performance than raw scroll events
            requestAnimationFrame(render);
        }

        function render() {
            const scrollTop = window.scrollY;
            const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
            const scrollFraction = Math.max(0, Math.min(1, scrollTop / (maxScroll || 1)));

            const frameIndex = Math.floor(scrollFraction * (settings.totalFrames - 1));
            const sheetIndex = Math.floor(frameIndex / settings.perSheet);
            const indexInSheet = frameIndex % settings.perSheet;

            // 1. Trigger the smart preload for surrounding sheets
            preloadSheets(sheetIndex);

            // 2. Draw the current frame if available
            const currentSheetUrl = getSheetUrl(sheetIndex);
            if (loadedBitmaps[currentSheetUrl]) {
                drawFrame(loadedBitmaps[currentSheetUrl], indexInSheet);
            }
        }

        function preloadSheets(currentIndex) {
            // Define how many sheets ahead/behind to keep in memory
            // 1 ahead and 1 behind is usually plenty for smooth scrolling
            const buffer = [-1, 0, 1];

            buffer.forEach(offset => {
                const targetIndex = currentIndex + offset;

                // Don't try to load sheets that don't exist (e.g., sheet -1)
                const totalSheets = Math.ceil(settings.totalFrames / settings.perSheet);
                if (targetIndex < 0 || targetIndex >= totalSheets) return;

                const url = getSheetUrl(targetIndex);

                // If not loaded and not already fetching, start the fetch
                if (!loadedBitmaps[url] && !loadingTracker[url]) {
                    loadingTracker[url] = true;
                    fetchAndDecode(url).then(bitmap => {
                        if (bitmap) {
                            loadedBitmaps[url] = bitmap;
                            // Only re-render if the newly loaded sheet is the one we actually need right now
                            const currentScrollIndex = Math.floor((window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * (settings.totalFrames - 1));
                            const currentSheetIndex = Math.floor(currentScrollIndex / settings.perSheet);
                            if (targetIndex === currentSheetIndex) {
                                render();
                            }
                        }
                    });
                }
            });
        }

        function drawFrame(imageBitmap, index) {
            const scale = Math.max(canvas.width / settings.sourceWidth, canvas.height / settings.sourceHeight);
            const x = (canvas.width / 2) - (settings.sourceWidth / 2) * scale;
            const y = (canvas.height / 2) - (settings.sourceHeight / 2) * scale;

            ctx.drawImage(
                imageBitmap,
                0, index * settings.sourceHeight, settings.sourceWidth, settings.sourceHeight,
                x, y, settings.sourceWidth * scale, settings.sourceHeight * scale
            );
        }

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            render();
        });

        init();

    </script>
</body>

</html>